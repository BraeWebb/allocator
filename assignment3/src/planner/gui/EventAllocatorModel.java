package planner.gui;

import planner.*;

import java.io.IOException;
import java.util.*;

/**
 * The model for the event allocator program.
 */
public class EventAllocatorModel {

    // a list of all the venues in the model
    private List<Venue> venues;
    // a list of all the events in the model
    private List<Event> events;
    // an allocation that allocates events to venues
    private Map<Event, Venue> allocation;

    /*
     * invariant:
     *
     * venues != null && events != null && allocation != null &&
     *
     * length of events == amount of mappings in allocation &&
     *
     * length of events <= length of venues &&
     *
     * traffic generated by allocation is safe &&
     *
     * for each event mapped to a venue in allocation, venue can host event
     */

    /**
     * Initialises the model for the event allocator program.
     */
    public EventAllocatorModel(){
        // initialize the instance variables
        venues = new ArrayList<>();
        events = new ArrayList<>();
        allocation = new HashMap<>();
    }

    /**
     * Load all the venues from the given filename into the model.
     *
     * @param filename the name of the file to load.
     * @throws IOException thrown if there is an error opening the file.
     * @throws FormatException throw if there is an error with the file format.
     */
    public void loadVenues(String filename) throws IOException, FormatException{
        venues = VenueReader.read(filename);
        events = new ArrayList<>();
        allocation = new HashMap<>();
    }

    /**
     * Attempts to add an event to the model based on the string representations
     * of the event name, event size and venue name.
     *
     * @param eventName the name of the event to add.
     * @param eventSize the string size of the event to add.
     * @param venueName the venue that the event should be added to.
     *
     * @throws IllegalArgumentException if the given venue does not exist in the
     *                                  current model or eventSize is not an
     *                                  integer or is less than zero or if the
     *                                  venue or event is currently assigned.
     * @throws InvalidTrafficException if the venue cannot host the event or
     *                                 if the traffic caused by adding event is
     *                                 unsafe.
     */
    public void addEvent(String eventName, String eventSize, String venueName){
        // attempts to find the given venue in the model
        Venue venue = this.findVenue(venueName);
        if (venue == null){
            throw new IllegalArgumentException("The specified venue could " +
                    "not be found");
        }

        // attempts to convert the given size into an integer
        int size;
        try {
            size = Integer.parseInt(eventSize);
        } catch (NumberFormatException e){
            throw new IllegalArgumentException("The event size must be an " +
                    "integer");
        }

        // ensures that the size is greater than zero
        if (size < 0){
            throw new IllegalArgumentException("The event size must be " +
                    "greater than zero");
        }

        // check that the venue does not already have an associated event
        if (allocation.containsValue(venue)){
            throw new IllegalArgumentException("The venue already has an event");
        }

        // creates an event object and ensures that is doesn't already
        // exist within the current allocation
        Event event = new Event(eventName, size);
        if (events.contains(event)){
            throw new IllegalArgumentException("The specified event is " +
                    "already allocated to a venue");
        }

        // attempts to add the event ensuring that the traffic is safe and possible
        if (!addEvent(event, venue)){
            throw new InvalidTrafficException(event.getName() +
                    " could not be added to the current allocation");
        }

    }

    /**
     * Adds an event to the model ensuring that the it is safe to do so.
     *
     * @param event The event to add to the model.
     * @param venue The venue to allocate the event to.
     * @return true iff the event can be safely added to the allocation.
     */
    public boolean addEvent(Event event, Venue venue){
        // ensure that venue can host this event
        if (venue.canHost(event)) {
            // add the traffic generated by the event at this venue
            Traffic traffic = new Traffic(getTraffic());
            traffic.addTraffic(venue.getTraffic(event));
            // ensure that the combined traffic is safe
            if(traffic.isSafe()){
                events.add(event);
                allocation.put(event, venue);
                return true;
            }
        }
        return false;
    }

    /**
     * Remove the event from the current allocation.
     *
     * @param event the event to remove from the allocation.
     */
    public void removeEvent(Event event){
        events.remove(event);
        allocation.remove(event);
    }

    /**
     * Find a venue in the model based on the name of the venue.
     *
     * @param venueName the name of the venue to search for.
     * @return the venue found in the model if it exists else null
     */
    private Venue findVenue(String venueName){
        for (Venue venue : venues){
            if (venue.getName().equals(venueName)) {
                return venue;
            }
        }
        return null;
    }

    /**
     * Returns the list of venues loaded into the allocator.
     *
     * @return a list of venues in the allocator.
     */
    public List<Venue> getVenues(){
        return venues;
    }

    /**
     * Returns the venue that is associated with the given event.
     *
     * @param event an event to search for it's venue pair.
     * @return the venue associated with the given event.
     */
    public Venue getVenue(Event event){
        return allocation.get(event);
    }

    /**
     * Returns the sorted list of events in the model.
     *
     * @return a list of sorted events.
     */
    public List<Event> getEvents(){
        // sort the events list using the EventComparator
        Collections.sort(events, new EventComparator());
        return events;
    }

    /**
     * Returns the total traffic caused by the current allocation.
     *
     * @return traffic caused by the current allocation.
     */
    public Traffic getTraffic(){
        Traffic traffic = new Traffic();
        for (Event event : allocation.keySet()) {
            Venue venue = allocation.get(event);

            traffic.addTraffic(venue.getTraffic(event));
        }
        return traffic;
    }

}

/**
 * A comparator for event objects that uses the toString method to compare.
 */
class EventComparator implements Comparator<Event> {
    public int compare(Event event1, Event event2) {
        return event1.toString().compareTo(event2.toString());
    }
}
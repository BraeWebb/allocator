package planner;

import java.io.*;
import java.util.*;

/**
 * Provides a method to read in a list of venues from a text file.
 */
public class VenueReader {

    /**
     * <p>
     * Reads a text file called fileName that describes the venues in a
     * municipality, and returns a list containing each of the venues read from
     * the file, in the order that they appear in the file.
     * </p>
     * 
     * <p>
     * The file contains zero or more descriptions of different venues. (I.e. a
     * file containing zero venues contains zero lines; a file containing one
     * venue contains exactly one description of a venue and no other lines or
     * information; a file containing multiple venues contains each description
     * of a venue, one after the other with no other information or lines in the
     * file.)
     * </p>
     * 
     * <p>
     * A description of a venue consists of exactly (i) one line consisting of
     * the name of the venue followed by (ii) one line containing a positive
     * integer denoting the capacity of the venue followed by (iii) a
     * description of the traffic generated by hosting an event of maximum size
     * at the venue, followed by (iv) an empty line.
     * </p>
     * 
     * <p>
     * For (i) the venue name is the entire string on the first line of the
     * venue description (i.e. it may contain white space characters etc.). The
     * only constraint on the venue name is that it may not be equal to the
     * empty string ("").
     * </p>
     * 
     * <p>
     * For (ii) the second line of a venue description may not contain leading
     * or trailing whitespace characters, it may only contain a positive integer
     * denoting the venue capacity.
     * </p>
     * 
     * <p>
     * For (iii) the traffic is described by one line for each corridor that
     * will have traffic from the venue when it hosts an event of maximum size.
     * Each line is a string of the form <br>
     * <br>
     * "START, END, CAPACITY: TRAFFIC"<br>
     * <br>
     * where START and END are different non-empty strings denoting the name of
     * the start location of the corridor and the end location of the corridor,
     * respectively; CAPACITY is a positive integer denoting the capacity of the
     * corridor; and TRAFFIC is a positive integer denoting the amount of
     * traffic from the venue that will use the corridor when the venue hosts
     * the largest event that it can. The strings denoting the start and end
     * locations of the corridor may contain any characters other than a comma
     * (',') or semicolon (':'). Both CAPACITY and TRAFFIC should be positive
     * integers with no additional leading or trailing whitespace. For example,
     * <br>
     * <br>
     * "St. Lucia, Royal Queensland Show - EKKA, 120: 60"<br>
     * <br>
     * represents a traffic corridor from "St. Lucia" to "Royal Queensland Show
     * - EKKA" with a maximum capacity of 120, that will have 60 people from the
     * venue using it when the venue hosts an event of maximum size. <br>
     * <br>
     * Note that the start, end and capacity of a corridor are separated by the
     * string ", ". The corridor and its traffic are separated by ": ". <br>
     * <br>
     * The corridors and their respective traffic may appear in any order (i.e.
     * the corridors aren't necessarily sorted in any way.) Each corridor may
     * only appear once in the traffic description for a venue (i.e. there is
     * only one line for each corridor), and the traffic on that corridor should
     * be less than or equal to the capacity of the venue, and less than or
     * equal to the capacity of the corridor.
     * </p>
     * 
     * <p>
     * For (iv) an empty line is a line with no characters at all (i.e. the
     * contents of the line is the empty string "").
     * </p>
     * 
     * <p>
     * Two equivalent venues shouldn't appear twice in the file.
     * </p>
     * 
     * <p>
     * If a FormatException is thrown, it will have a meaningful message that
     * accurately describes the problem with the input file format, including
     * the line of the file where the problem was detected.
     * </p>
     * 
     * @param fileName
     *            the name of the file to read from.
     * @return a list of the venues from the file, in the order in which they
     *         appear in the file.
     * @throws IOException
     *             if there is an error reading from the input file.
     * @throws FormatException
     *             if there is an error with the input format (e.g. there is
     *             more than one venue description in the file that describes
     *             the same venue, or the file format is not as specified above
     *             in any other way.) The FormatExceptions thrown should have a
     *             meaningful message that accurately describes the problem with
     *             the input file format, including the line of the file where
     *             the problem was detected.
     */
    public static List<Venue> read(String fileName) throws IOException,
            FormatException {

        // stores the venues loaded from the file
        ArrayList<Venue> venues = new ArrayList<>();
        // the appropriate readers and scanners to allow iteration of the files
        FileReader fileReader;
        Scanner scanner;

        try {
            // load the file reader and file scanner
            fileReader = new FileReader(fileName);
            scanner = new Scanner(fileReader);
        } catch (FileNotFoundException e) {
            throw new IOException("The provided file " + fileName +
                    " could not be found");
        }

        // stores temporary information about the venue that persist through
        // each line
        String venueName = null;
        int venueCapacity = -1;
        Traffic traffic = new Traffic();
        int venueLine = 0;

        // define the line so that it can be used at the end of the loop
        String line = "";
        // stores the current line number for error logging
        int lineNumber = 0;

        // loop through each line in the file
        while (scanner.hasNextLine()) {

            line = scanner.nextLine();
            lineNumber++;

            // if the line is empty create the venue based on the information
            // currently stored
            if (line.trim().isEmpty()){
                if (venueName == null || venueCapacity == -1){
                    throw new FormatException("A new line was encountered " +
                            "before a venue was defined at line "
                            + lineNumber + ".");
                }
                Venue venue;
                try {
                    venue = new Venue(venueName, venueCapacity, traffic);
                } catch (InvalidTrafficException e) {
                    throw new FormatException("Traffic in at least one " +
                            "corridor is greater than the maximum capacity " +
                            "of the venue.");
                } catch (IllegalArgumentException e){
                    throw new FormatException("Traffic of the venue at line "
                            + venueLine + " is less than or equal to zero.");
                }
                if (venues.contains(venue)) {
                    throw new FormatException("Duplicate venue found starting" +
                            " at line " + venueLine);
                }
                // reset venue variables to their original state
                venueName = null;
                venueCapacity = -1;
                traffic = new Traffic();

                // add the new venue to the venue list
                venues.add(venue);

                continue;
            }

            // when venue hasn't been named name it the first non-empty line
            if(venueName == null){
                venueName = line;
                venueLine = lineNumber;
            }
            // when the venue capacity hasn't been assigned try to assign it
            else if(venueCapacity == -1){
                try {
                    venueCapacity = Integer.parseInt(line.trim());
                } catch (NumberFormatException exception){
                    throw new FormatException("Venue capacity at line " +
                            lineNumber + " is not an integer.");
                }
            // any other lines should correspond to corridors
            } else {
                readCorridor(line, lineNumber, traffic);
            }
        }
        // ensure that the last line of the file is not empty
        if(!line.isEmpty()){
            throw new FormatException("The last line of the file must be empty");
        }

        // close the file and scanner used to read the file
        fileReader.close();
        scanner.close();
        return venues;
    }


    /**
     * Reads a corridor and traffic from the provided line and adds the result
     * to the provided traffic.
     *
     * The line should be in the form
     * START_LOCATION, END_LOCATION, CAPACITY: TRAFFIC
     * Where START_LOCATION is the string name of the starting location,
     * END_LOCATION is the string name of the end location, CAPACITY is the
     * maximum capacity of the corridor and TRAFFIC is the current amount
     * of traffic in the given corridor.
     *
     * @param line The line to read for the corridor and traffic information.
     * @param lineNumber The line number of the current line which is used for
     *                   error messages.
     * @param traffic The traffic to update with the data read from the line.
     * @throws FormatException
     *              if the line is not in the correct format for a corridor
     *              traffic line.
     */
    private static void readCorridor(String line, int lineNumber, Traffic traffic)
            throws FormatException {
        // split the line up into the values expected
        // could probably have been combined
        // String[] capacity = locations[2].split("\\s*:\\s");
        String[] locations = line.split("\\s*,\\s");
        // ensure there are the correct amount of values
        if (locations.length != 3){
            throw new FormatException("Corridor is incorrectly " +
                    "formatted on line " + lineNumber);
        }

        // split the last value into the capacity and traffic
        String[] capacityTraffic = locations[2].split("\\s*:\\s");
        // ensure there are the correct amount of values
        if (capacityTraffic.length != 2){
            throw new FormatException("Corridor is incorrectly " +
                    "formatted on line " + lineNumber);
        }

        // ensure that the start location and end locations are not empty
        if (locations[0].isEmpty() || locations[1].isEmpty()){
            throw new FormatException("The start or end location " +
                    "names were empty on line " + lineNumber);
        }

        Location start = new Location(locations[0]);
        Location end = new Location(locations[1]);

        int capacity;
        // try to convert the capacity into an integer
        try {
            capacity = Integer.parseInt(capacityTraffic[0]);
        } catch (NumberFormatException e){
            throw new FormatException("The capacity of the corridor " +
                    "on line " + lineNumber + " was not an integer " +
                    "(found: " + capacityTraffic[0] + ")");
        }

        Corridor corridor;
        try {
            corridor = new Corridor(start, end, capacity);
        }  catch (IllegalArgumentException e){
            // if the locations are equal raise a format exception
            if (capacity > 0) {
                throw new FormatException("Start and end locations " +
                        "of the corridor on line " + lineNumber
                        + " are equal");
            }
            // ensure that the capacity of the corridor is positive
            throw new FormatException("Capacity of the corridor on " +
                    "line " + lineNumber + " was less than or equal " +
                    "to zero");
        }

        // ensure that the corridor is not a duplicate
        if (traffic.getCorridorsWithTraffic().contains(corridor)){
            throw new FormatException("Corridor only line " + lineNumber
                    + " is already described for the venue.");
        }

        int trafficAmount;
        // try to convert the capacity into an integer
        try {
            trafficAmount = Integer.parseInt(capacityTraffic[1]);
        } catch (NumberFormatException e){
            throw new FormatException("The traffic of the corridor " +
                    "on line " + lineNumber + " was not an integer " +
                    "(found: " + capacityTraffic[1] + ")");
        }

        // ensure that the traffic does not exceed the capacity
        if (trafficAmount > corridor.getCapacity()){
            throw new FormatException("Traffic of the corridor on line "
                    + lineNumber + " exceeds the capacity.");
        }

        // update the traffic with the new corridor and traffic
        // retrieved from the file
        try {
            traffic.updateTraffic(corridor, trafficAmount);
        } catch (InvalidTrafficException exception){
            throw new FormatException("Traffic on the corridor on line "
                    + lineNumber + " is negative");
        }
    }

}
package planner;

import java.util.*;

/**
 * Provides a method for finding a safe allocation of events to venues.
 */
public class Allocator {

    /**
     * <p>
     * Returns a safe allocation of events to venues, if there is at least one
     * possible safe allocation, or null otherwise.
     * </p>
     * 
     * <p>
     * NOTE: What it means for an allocation of events to venues to be safe is
     * defined in the assignment handout.
     * </p>
     * 
     * @require events != null && venues != null && !events.contains(null) &&
     *          !venues.contains(null) && events does not contain duplicate
     *          events && venues does not contain duplicate venues.
     * @ensure Returns a safe allocation of events to venues, if there is at
     *         least one possible safe allocation, or null otherwise.
     */
    public static Map<Event, Venue> allocate(List<Event> events,
            List<Venue> venues) {
        // DO NOT MODIFY THE IMPLEMENTATION OF THIS METHOD
        Set<Map<Event, Venue>> allocations = allocations(events, venues);
        if (allocations.isEmpty()) {
            // returns null to signify that there is no possible safe allocation
            return null;
        } else {
            // returns one (any one) of the possible safe allocations
            return allocations.iterator().next();
        }
    }

    /**
     * Returns the set of all possible safe allocations of events to venues.
     * 
     * @require events != null && venues != null && !events.contains(null) &&
     *          !venues.contains(null) && events does not contain duplicate
     *          events && venues does not contain duplicate venues.
     * @ensure Returns the set of all possible safe allocations of events to
     *         venues. (Note: if there are no possible allocations, then this
     *         method should return an empty set of allocations.)
     */
    private static Set<Map<Event, Venue>> allocations(List<Event> events,
            List<Venue> venues) {

        // base case when there are no events to allocate
        if (events.size() == 0){
            return new HashSet<>();
        }
        // when there are more events than venues there are no safe allocations
        if (events.size() > venues.size()){
            return new HashSet<>();
        }

        // store the allocations to be returned
        Set<Map<Event, Venue>> result = new HashSet<>();
        // get the first event in the list to process
        Event first = events.get(0);

        for (Venue venue: venues){
            // ensure that the first event can be hosted at the venue and it
            // would be safe
            if (venue.canHost(first) && venue.getTraffic(first).isSafe()){
                // remove the first items from the lists
                List<Event> eventList = new ArrayList<>(events);
                eventList.remove(first);
                List<Venue> venueList = new ArrayList<>(venues);
                venueList.remove(venue);

                // recursively retrieve the valid allocations of the rest of the
                // events and venues
                Set<Map<Event, Venue>> suballocations = allocations(eventList,
                        venueList);

                // if there are no suballocations then fill the result with the
                // removed values
                if (suballocations.size() == 0){
                    Map<Event, Venue> allocation = new HashMap<>();
                    allocation.put(first, venue);

                    if (isAllocationSafe(allocation)) {
                        result.add(allocation);
                    }
                }

                // re-add the removed elements to the suballocations and add
                // them to the result if they are safe
                for (Map<Event, Venue> rest : suballocations){
                    rest.put(first, venue);

                    if (isAllocationSafe(rest)) {
                        result.add(rest);
                    }
                }
            }
        }
        // ensure that each event maps to a venue that can host it
        for (Map<Event, Venue> map : result) {
            if (map.size() != events.size()) {
                return new HashSet<>();
            }
        }
        return result;
    }

    /**
     * Returns true iff the total traffic generated by the given allocation is
     * a safe amount of traffic.
     *
     * @param allocation An allocation of events to venues.
     * @return true iff the traffic generated by the allocation is safe.
     *
     * @throws NullPointerException
     *              if the given allocation is null or if any event or venue
     *              contained within the allocation is null.
     */
    private static boolean isAllocationSafe(Map<Event, Venue> allocation) {
        if (allocation == null){
            throw new NullPointerException("Allocation must not be null");
        }

        // the total amount of traffic produced by the allocation
        Traffic totalTraffic = new Traffic();
        for (Event event : allocation.keySet()){
            if (event == null || allocation.get(event) == null){
                throw new NullPointerException("Events and venues within the " +
                        "allocation must not be null");
            }
            // increase the total traffic by the amount of traffic generated by
            // an event at a venue
            Venue venue = allocation.get(event);
            totalTraffic.addTraffic(venue.getTraffic(event));
        }
        // return whether the total traffic is safe or not
        return totalTraffic.isSafe();
    }

}
